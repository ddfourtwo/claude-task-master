Below you will find a variety of important rules spanning:
- the dev_workflow
- the .clauderules document self-improvement workflow
- the template to follow when modifying or adding new sections/rules to this document.

---
DEV_WORKFLOW
---
description: Guide for using taskmaster-ai MCP server integration for managing test-task-driven development workflows
globs: **/*
filesToApplyRule: **/*
alwaysApply: true
---

- **MCP Server Tools**
  - TaskMaster provides a set of MCP tools for Claude 
  - These tools provide direct integration with the TaskMaster system
  - All functionality is available through MCP server tools
  - Main tool categories:
    - Project initialization: `initialize_project`, `parse_prd`, `models`
    - Task viewing: `get_tasks`, `get_task`, `next_task`, `complexity_report`
    - Task management: `set_task_status`, `generate`, `add_task`
    - Task modification: `update`, `update_task`, `update_subtask`, `add_subtask`, `remove_task`, `remove_subtask`
    - Task expansion: `expand_task`, `expand_all`, `analyze_project_complexity`, `clear_subtasks`
    - Dependency handling: `add_dependency`, `remove_dependency`, `validate_dependencies`, `fix_dependencies`
  - All tools accept specific parameters appropriate to their function

- **Global CLI Commands**
  - TaskMaster also provides a global CLI through the `task-master` command
  - All functionality is available through this interface
  - Examples:
    - `task-master list` to list tasks
    - `task-master next` to get the next task
    - `task-master expand --id=3` to expand a task
  - All commands accept the same options as their MCP tool equivalents

- **Development Workflow Process**
  - Start new projects by running `initialize_project` MCP tool or `task-master init` CLI command
  - Generate initial tasks using `parse_prd` MCP tool with your requirements document
  - Begin coding sessions with `get_tasks` to see current tasks, status, and IDs
  - Analyze task complexity with `analyze_project_complexity` before breaking down tasks
  - Select tasks based on dependencies (all marked 'done'), priority level, and ID order
  - View specific task details using `get_task` to understand implementation requirements
  - Break down complex tasks using `expand_task` with appropriate parameters
  - Clear existing subtasks if needed using `clear_subtasks` before regenerating
  - Implement code following task details, dependencies, and project standards
  - Verify tasks according to test strategies before marking as complete
  - Mark completed tasks with `set_task_status`
  - Update dependent tasks when implementation differs from original plan
  - Generate task files with `generate` after updating tasks.json
  - Maintain valid dependency structure with `fix_dependencies` when needed
  - Respect dependency chains and task priorities when selecting work
  - Report progress regularly using the get_tasks tool

- **Task Complexity Analysis**
  - Run `analyze_project_complexity` MCP tool with research=true for comprehensive analysis
  - Review complexity report using `complexity_report` tool
  - Focus on tasks with highest complexity scores (8-10) for detailed breakdown
  - Use analysis results to determine appropriate subtask allocation
  - Note that reports are automatically used by the expand_task tool

- **Task Breakdown Process**
  - For tasks with complexity analysis, use `expand_task`
  - Add research=true parameter to leverage Perplexity AI for research-backed expansion
  - Provide additional context in the prompt parameter when needed
  - Review and adjust generated subtasks as necessary
  - Use `expand_all` to expand multiple pending tasks at once
  - If subtasks need regeneration, clear them first with `clear_subtasks` tool

- **Implementation Drift Handling**
  - When implementation differs significantly from planned approach
  - When future tasks need modification due to current implementation choices
  - When new dependencies or requirements emerge
  - Use `update` tool with fromTaskId and prompt parameters

- **Task Status Management**
  - Use 'pending' for tasks ready to be worked on
  - Use 'done' for completed and verified tasks
  - Use 'deferred' for postponed tasks
  - Add custom status values as needed for project-specific workflows

- **Task File Format Reference**
  ```
  # Task ID: <id>
  # Title: <title>
  # Status: <status>
  # Dependencies: <comma-separated list of dependency IDs>
  # Priority: <priority>
  # Description: <brief description>
  # Details:
  <detailed implementation notes>
  
  # Test Strategy:
  <verification approach>
  ```

- **Task Structure Fields**
  - **id**: Unique identifier for the task (Example: `1`)
  - **title**: Brief, descriptive title (Example: `"Initialize Repo"`)
  - **description**: Concise summary of what the task involves (Example: `"Create a new repository, set up initial structure."`)
  - **status**: Current state of the task (Example: `"pending"`, `"done"`, `"deferred"`)
  - **dependencies**: IDs of prerequisite tasks (Example: `[1, 2]`)
    - Dependencies are displayed with status indicators (✅ for completed, ⏱️ for pending)
    - This helps quickly identify which prerequisite tasks are blocking work
  - **priority**: Importance level (Example: `"high"`, `"medium"`, `"low"`)
  - **details**: In-depth implementation instructions (Example: `"Use GitHub client ID/secret, handle callback, set session token."`)
  - **testStrategy**: Verification approach (Example: `"Deploy and call endpoint to confirm 'Hello World' response."`)
  - **subtasks**: List of smaller, more specific tasks (Example: `[{"id": 1, "title": "Configure OAuth", ...}]`)


- **Determining the Next Task**
  - Use `next_task` MCP tool to show the next task to work on
  - The tool identifies tasks with all dependencies satisfied
  - Tasks are prioritized by priority level, dependency count, and ID
  - The response shows comprehensive task information including:
    - Basic task details and description
    - Implementation details
    - Subtasks (if they exist)
    - Contextual suggested actions
  - Recommended before starting any new development work
  - Respects your project's dependency structure
  - Ensures tasks are completed in the appropriate sequence

- **Viewing Specific Task Details**
  - Use `get_task` MCP tool with the id parameter to view a specific task
  - Use dot notation for subtasks: id=1.2 (shows subtask 2 of task 1)
  - Displays comprehensive information similar to the next_task tool, but for a specific task
  - For parent tasks, shows all subtasks and their current status
  - For subtasks, shows parent task information and relationship
  - Provides contextual information appropriate for the specific task
  - Useful for examining task details before implementation or checking status

- **Managing Task Dependencies**
  - Use `add_dependency` MCP tool to add a dependency
  - Use `remove_dependency` MCP tool to remove a dependency
  - The system prevents circular dependencies and duplicate dependency entries
  - Dependencies are checked for existence before being added or removed
  - Task files are automatically regenerated after dependency changes
  - Dependencies are visualized with status indicators in task listings and files

- **Code Analysis & Refactoring Techniques**
  - **Top-Level Function Search**
    - Use grep pattern matching to find all exported functions across the codebase
    - Command: `grep -E "export (function|const) \w+|function \w+\(|const \w+ = \(|module\.exports" --include="*.js" -r ./`
    - Benefits:
      - Quickly identify all public API functions without reading implementation details
      - Compare functions between files during refactoring (e.g., monolithic to modular structure)
      - Verify all expected functions exist in refactored modules
      - Identify duplicate functionality or naming conflicts
    - Usage examples:
      - When examining MCP tools structure: `grep -E "export function register\w+" mcp-server/src/tools/`
      - Check function exports in a directory: `grep -E "export (function|const)" scripts/modules/`
      - Find potential naming conflicts: `grep -E "function (get|set|create|update)\w+\(" -r ./`
    - Variations:
      - Add `-n` flag to include line numbers
      - Add `--include="*.ts"` to filter by file extension
      - Use with `| sort` to alphabetize results
    - Integration with refactoring workflow:
      - Start by mapping all functions in the source file
      - Create target module files based on function grouping
      - Verify all functions were properly migrated
      - Check for any unintentional duplications or omissions

---
CLAUDE_RULES
---
description: Guidelines for creating and maintaining Claude rules to ensure consistency and effectiveness.
globs: .clauderules
filesToApplyRule: .clauderules
alwaysApply: true
---
The below describes how you should be structuring new rule sections in this document.
- **Required Rule Structure:**
  ```markdown
  ---
  description: Clear, one-line description of what the rule enforces
  globs: path/to/files/*.ext, other/path/**/*
  alwaysApply: boolean
  ---

  - **Main Points in Bold**
    - Sub-points with details
    - Examples and explanations
  ```

- **Section References:**
  - Use `ALL_CAPS_SECTION` to reference files
  - Example: `CLAUDE_RULES`

- **Code Examples:**
  - Use language-specific code blocks
  ```typescript
  // ✅ DO: Show good examples
  const goodExample = true;
  
  // ❌ DON'T: Show anti-patterns
  const badExample = false;
  ```

- **Rule Content Guidelines:**
  - Start with high-level overview
  - Include specific, actionable requirements
  - Show examples of correct implementation
  - Reference existing code when possible
  - Keep rules DRY by referencing other rules

- **Rule Maintenance:**
  - Update rules when new patterns emerge
  - Add examples from actual codebase
  - Remove outdated patterns
  - Cross-reference related rules

- **Best Practices:**
  - Use bullet points for clarity
  - Keep descriptions concise
  - Include both DO and DON'T examples
  - Reference actual code over theoretical examples
  - Use consistent formatting across rules 

---
SELF_IMPROVE
---
description: Guidelines for continuously improving this rules document based on emerging code patterns and best practices.
globs: **/*
filesToApplyRule: **/*
alwaysApply: true
---

- **Rule Improvement Triggers:**
  - New code patterns not covered by existing rules
  - Repeated similar implementations across files
  - Common error patterns that could be prevented
  - New libraries or tools being used consistently
  - Emerging best practices in the codebase

- **Analysis Process:**
  - Compare new code with existing rules
  - Identify patterns that should be standardized
  - Look for references to external documentation
  - Check for consistent error handling patterns
  - Monitor test patterns and coverage

- **Rule Updates:**
  - **Add New Rules When:**
    - A new technology/pattern is used in 3+ files
    - Common bugs could be prevented by a rule
    - Code reviews repeatedly mention the same feedback
    - New security or performance patterns emerge

  - **Modify Existing Rules When:**
    - Better examples exist in the codebase
    - Additional edge cases are discovered
    - Related rules have been updated
    - Implementation details have changed

- **Example Pattern Recognition:**
  ```typescript
  // If you see repeated patterns like:
  const data = await prisma.user.findMany({
    select: { id: true, email: true },
    where: { status: 'ACTIVE' }
  });
  
  // Consider adding a PRISMA section in the .clauderules:
  // - Standard select fields
  // - Common where conditions
  // - Performance optimization patterns
  ```

- **Rule Quality Checks:**
  - Rules should be actionable and specific
  - Examples should come from actual code
  - References should be up to date
  - Patterns should be consistently enforced

- **Continuous Improvement:**
  - Monitor code review comments
  - Track common development questions
  - Update rules after major refactors
  - Add links to relevant documentation
  - Cross-reference related rules

- **Rule Deprecation:**
  - Mark outdated patterns as deprecated
  - Remove rules that no longer apply
  - Update references to deprecated rules
  - Document migration paths for old patterns

- **Documentation Updates:**
  - Keep examples synchronized with code
  - Update references to external docs
  - Maintain links between related rules
  - Document breaking changes

Follow CLAUDE_RULES for proper rule formatting and structure of claude rule sections.